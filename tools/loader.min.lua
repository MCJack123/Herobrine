if"ä"~="\xE4"then local a=assert(fs.open(shell.getRunningProgram(),"rb"))local b=a.readAll()a.close()return assert(load(b,"@"..shell.getRunningProgram(),nil,_ENV))()end;if#disk~=size then error("File corrupted (expected "..size..", got "..#disk..")")end;local c=require"cc.expect"local d,e,f=bit32.rshift,bit32.lshift,bit32.band;local g,h=string.byte,string.char;local i,unpack=table.concat,unpack or table.unpack;local j=math.min;local k={17,18,19,1,9,8,10,7,11,6,12,5,13,4,14,3,15,2,16}local l={2,3,7}local m={144,112,24,8}local n={8,9,7,8}local o={[0]=5,261,133,389,69,325,197,453,37,293,165,421,101,357,229,485,21,277,149,405,85,341,213,469,53,309,181,437,117,373,245,501}local p=5;local function q(r,s)r.bits=d(r.bits,s)r.count=r.count-s end;local function t(r,s)local u,v,w,x=r.buffer,r.bits,r.count,r.position;while w<s do if x>#u then return nil end;v=v+e(g(u,x),w)x=x+1;w=w+8 end;r.bits=v;r.position=x;r.count=w;return f(v,e(1,s)-1)end;local function y(r,s)local z=t(r,s)r.bits=d(r.bits,s)r.count=r.count-s;return z end;local function A(r,B,s)local C=B[t(r,s)]if not C then return nil end;local D=f(C,15)local z=d(C,4)r.bits=d(r.bits,D)r.count=r.count-D;return z end;local function E(F)local size=#F;local G,H,B={[0]=0},{},{}local v,I=1,0;for J=1,size do local K=F[J]if K>v then v=K end;G[K]=(G[K]or 0)+1 end;for J=1,v do I=(I+(G[J-1]or 0))*2;H[J]=I end;for J=1,size do local K=F[J]if K>0 then local C=(J-1)*16+K;local L=0;for M=1,K do L=L+e(f(1,d(H[K],M-1)),K-M)end;for M=0,2^v-1,2^K do B[M+L]=C end;H[K]=H[K]+1 end end;return B,v end;local function N(O,r,P,Q,R,S)local T=#O+1;local U;repeat U=A(r,P,Q)if not U then return nil end;if U<256 then O[T]=U;T=T+1 elseif U>256 then local v,size,V=0,3,1;if U<265 then size=size+U-257 elseif U<285 then v=d(U-261,2)size=size+e(f(U-261,3)+4,v)else size=258 end;if v>0 then size=size+y(r,v)end;local C=A(r,R,S)if C<4 then V=V+C else v=d(C-2,1)V=V+e(f(C,1)+2,v)+y(r,v)end;local x=T-V;repeat O[T]=O[x]or 0;T=T+1;x=x+1;size=size-1 until size==0 end until U==256 end;local function W(O,r)local X=y(r,5)if not X then return nil end;local U,V,D=257+X,1+y(r,5),4+y(r,4)local F={}for J=1,D do F[k[J]]=y(r,3)end;for J=D+1,19 do F[k[J]]=0 end;local Y,Z=E(F)local J=1;local _=U+V+1;repeat local C=A(r,Y,Z)if C<16 then F[J]=C;J=J+1 elseif C<19 then local s=l[C-15]local w=0;local a0=3+y(r,s)if C==16 then w=F[J-1]elseif C==18 then a0=a0+8 end;for a1=1,a0 do F[J]=w;J=J+1 end end until J==_;local a2,a3={},{}for M=1,U do a2[M]=F[M]end;for M=U+1,#F do a3[#a3+1]=F[M]end;local P,Q=E(a2)local R,S=E(a3)N(O,r,P,Q,R,S)end;local function a4(O,r)local F={}for J=1,4 do local K=n[J]for a1=1,m[J]do F[#F+1]=K end end;local P,Q=E(F)N(O,r,P,Q,o,p)end;local function a5(O,r)q(r,f(r.count,7))local D=y(r,16)y(r,16)if not D then return nil end;local u,x=r.buffer,r.position;for J=x,x+D-1 do O[#O+1]=g(u,J,J)end;r.position=x+D end;local function a6(b)local self={buffer=b,position=1,bits=0,count=0}local O,u={},{}local a7,a8;repeat a7,a8=y(self,1),y(self,2)if not a7 or not a8 then break end;a8=a8==0 and a5(O,self)or a8==1 and a4(O,self)or a8==2 and W(O,self)until a7==1;local size=#O;for J=1,size,4096 do u[#u+1]=h(unpack(O,J,j(J+4095,size)))end;return i(u)end;local function a9(aa,ab)for ac in fs.combine(ab):gmatch("[^/]+")do aa=aa[ac]if aa==nil then return nil end end;return aa end;local function ad(ae,af)if#ae==0 then return type(af)=="table"and""or af elseif type(af)~="table"then return nil end;local ag={}for J,ah in ipairs(ae)do ag[J]=ah end;local ai=table.remove(ag,1)local aj={}if af then for ak,ah in pairs(af)do if ak:match("^"..ai:gsub("([%%%.])","%%%1"):gsub("%*","%.%*").."$")then aj[ak]=ad(ag,ah)end end end;return aj end;local function al(af,am)am=am or""if af==nil then return{}end;local aj={}for ak,ah in pairs(af)do if type(ah)=="string"then table.insert(aj,am..ak)else for a1,an in ipairs(al(ah,am..ak.."/"))do table.insert(aj,an)end end end;return aj end;term.setBackgroundColor(colors.black)term.setTextColor(colors.lime)term.clear()term.setCursorPos(1,1)write("PRE-LOAD INIT...")term.setCursorBlink(true)local b=a6(disk)disk=textutils.unserialize(b)sleep(0)local fs=fs;_G.fs={list=function(ab)c(1,ab,"string")if ab:match"^/?rom"then return fs.list(ab)end;local aa=a9(disk,ab)if type(aa)~="table"then error(ab..": Not a directory",2)end;local aj={}for ak in pairs(aa)do aj[#aj+1]=ak end;local ae={}for ac in fs.combine(ab):gmatch("[^/]+")do ae[#ae+1]=ac end;table.sort(aj)return aj end,exists=function(ab)c(1,ab,"string")if ab:match"^/?rom"then return fs.exists(ab)end;return a9(disk,ab)~=nil end,isDir=function(ab)c(1,ab,"string")if ab:match"^/?rom"then return fs.isDir(ab)end;local aa=a9(disk,ab)return type(aa)=="table"end,isReadOnly=function(ab)c(1,ab,"string")return true end,getName=fs.getName,getDrive=function(ab)c(1,ab,"string")return"hdd"end,getSize=function(ab)c(1,ab,"string")if ab:match"^/?rom"then return fs.getSize(ab)end;local aa=a9(disk,ab)if aa==nil then error(ab..": No such file")end;if type(aa)=="table"then return 0 else return#aa end end,getFreeSpace=function(ab)c(1,ab,"string")return 0 end,makeDir=function(ab)error("Read only filesystem",2)end,move=function()error("Read only filesystem",2)end,copy=function()error("Read only filesystem",2)end,delete=function()error("Read only filesystem",2)end,combine=fs.combine,open=function(ab,ao)c(1,ab,"string")c(2,ao,"string")if ab:match"^/?rom"then return fs.open(ab,ao)end;if ao=="r"then local aa=a9(disk,ab)if type(aa)~="string"then return nil,"No such file"end;local ap=aa;aa=""for a1,aq in utf8.codes(ap)do aa=aa..(aq>255 and"?"or string.char(aq))end;aa=aa:gsub("\r\n","\n")local ar=1;local as=false;return{readLine=function(at)if as then error("file is already closed",2)end;if ar>#aa then return end;local au,av=aa:match(at and"([^\n]*\n?)()"or"([^\n]*)\n?()",ar)ar=au and av or#aa+1;return au end,readAll=function()if as then error("file is already closed",2)end;if#aa==0 and ar==1 then ar=2;return""end;if ar>#aa then return end;local aw=ar;ar=#aa+1;return aa:sub(aw)end,read=function(w)if as then error("file is already closed",2)end;if ar>#aa then return end;c(1,w,"number","nil")w=w or 1;local aw=ar;ar=ar+w;return aa:sub(aw,ar-1)end,close=function()if as then error("file is already closed",2)end;as=true end}elseif ao=="w"or ao=="a"then return nil,"Read only filesystem"elseif ao=="rb"then local aa=a9(disk,ab)if type(aa)~="string"then return nil,"No such file"end;local ar=1;local as=false;return{readLine=function(at)if as then error("file is already closed",2)end;if ar>#aa then return end;local au,av=aa:match(at and"([^\n]*\n?)()"or"([^\n]*)\n?()",ar)ar=au and av or#aa+1;return au end,readAll=function()if as then error("file is already closed",2)end;if#aa==0 and ar==1 then ar=2;return""end;if ar>#aa then return end;local aw=ar;ar=#aa+1;return aa:sub(aw)end,read=function(w)c(1,w,"number","nil")if as then error("file is already closed",2)end;if ar>#aa then return end;if w==nil then ar=ar+1;return aa:byte(ar-1)else local aw=ar;ar=ar+w;return aa:sub(aw,ar-1)end end,close=function()if as then error("file is already closed",2)end;as=true end,seek=function(ax,ay)if as then error("file is already closed",2)end;c(1,ax,"string","nil")c(2,ay,"number","nil")ax=ax or"cur"ay=ay or 0;if ax=="set"then ar=ay+1 elseif ax=="cur"then ar=ar+ay elseif ax=="end"then ar=#aa-ay else error("bad argument #1 (invalid option "..ax..")",2)end;return ar end}elseif ao=="wb"or ao=="ab"then return nil,"Read only filesystem"else return nil,"Invalid mode"end end,find=function(az)c(1,az,"string")local ae={}for ac in az:gmatch("[^/]+")do ae[#ae+1]=ac end;local aj={}for a1,ah in ipairs(al(ad(ae,disk)))do table.insert(aj,ah)end;table.sort(aj)return aj end,getDir=fs.getDir,attributes=function(ab)c(1,ab,"string")if ab:match"^/?rom"then return fs.attributes(ab)end;local aa=a9(disk,ab)return{size=type(aa)=="table"and 0 or#aa,isDir=type(aa)=="table",isReadOnly=false,created=0,modified=0}end,getCapacity=function(ab)c(1,ab,"string")return 1000000 end}local aA,aB=pcall(shell.run,"player")_G.fs=fs;if not aA then printError(aB)end
